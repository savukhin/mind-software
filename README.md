[![Contact me](https://img.shields.io/badge/Telegram-msc_15-blue.svg)](https://t.me/msc_15)
![example workflow](https://github.com/savukhin/mind-software/actions/workflows/test.yaml/badge.svg)

# mind-software

## Текст задания
Приложение хранит в себе идентификаторы объектов и лог текстовых сообщений с таймстемпами этих сообщений. Взаимодействие с приложением осуществляется исключительно с помощью брокера очередей.
По требованию внешней системы, микросервис может дописать сообщение в лог объекта с актуальным таймстемпом.
Количество сообщений в логе может быть большим, условно не ограничено. При этом должна быть обеспечена возможность получения сообщений лога по объекту в отсортированном по таймстемпу виде.
После проведения операции генерируется событие-ответ в одну из очередей.

Основные требования к воркерам приложения:
Код воркеров должен безопасно выполняться параллельно в разных процессах
Воркеры могут запускаться одновременно в любом числе экземпляров и выполняться произвольное время
Все операции должны обрабатываться корректно, без дублирования логов и потери сообщений при одновременной записи в лог одного объекта нескольких воркеров.

В пояснительной записке к выполненному заданию необходимо указать перечень используемых инструментов и технологий, способ развертки приложения, общий механизм работы (интерфейсы ввода/вывода)
  
Требования к окружению:
* Язык программирования: Go 1.17+
* Можно использовать: любые фреймворки, реляционные БД для хранения баланса, брокеры очередей, key-value хранилища, код должен быть готовым к покрытию unit тестами


## Способ развёртки
* Склонировать репозиторий
```bash
git clone git@github.com:savukhin/mind-software.git
```
* Чтобы развернуть среду с воркерами, запустите команду
```bash
docker compose up --build --remove-orphans
```
Если зайти по адресу http://localhost:2112/metrics, то можно увидеть стандартные метрики в go.

Увеличить количество баз данных можно добавлением блока с описанием базы данных по аналогии с postgresnode, причём необходимы одинаковые логины/пароли для всех узлов БД. Затем добавить новое название контейнера в поле окружения **POSTGRES_IPS** сервиса worker.

* Если вы хотите посмотреть поведение при нагрузке, то нужно запустить docker-compose.test.yaml:
```bash
docker-compose -f docker-compose.test.yaml up --build --remove-orphans
```
Это по сути то же окружение, что и в прошлом варианте, но с добавлением сервиса, который создаёт нагрузку (пишет в NATS)
Обратите внимание, что нагрузку можно изменить при помощи поля **QUERIES_MIN**, которое отражает количество запросов в минуту. Отправляются только запросы на добавление логов.
Если вы хотите увеличить количество реплик для тестирования, то надо изменить **services.worker.deploy.replicas** на нужное значение и не забыть закомментировать поле **services.worker.port**, если количество реплик больше, чем 1, так как нельзя несколько раз открыть один и тот же порт.

## Диаграмма взаимодействия

![Diargam](./readme/Diagram.png?raw=true "Diagram")
* [Nats](https://nats.io/) - брокер сообщений NATS, через которого приходят сообщения
* [Postgres](https://www.postgresql.org/) - База данных, в которой хранится информация
* [Hashring](https://pkg.go.dev/github.com/serialx/hashring) -  Подход к шардированию, при котором инстансы БД располагаются по кругу; вычисляется хэш ключа и отправляется в соответствующую БД.
* Workers - набор воркеров-решений поставленной задачи


## Механизм работы

В Nats три топика: 
* **logs** - логи, сообщение является json-строкой, которая десериализуется в объект следующего типа:
```go
type NatsLogMsg struct {
	ObjId uint64 `json:"id"`
	Log   string `json:"log"`
}
```

* **query** - запросы на сбор логов по идентицфикатору объекта, хранятся JSON-е, которая преобразуется в следующий объект:
```go
type NatsGetLogsMsg struct {
	ObjId uint64 `json:"id"`
}
```

* **response** - ответы на запросы из query:
```go
type NatsGetLogsMsg struct {
	ObjId uint64 `json:"id"`
}
```
