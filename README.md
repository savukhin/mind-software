[![Contact me](https://img.shields.io/badge/Telegram-msc_15-blue.svg)](https://t.me/msc_15)
![example workflow](https://github.com/savukhin/mind-software/actions/workflows/test.yaml/badge.svg)

# mind-software

## Текст задания
Приложение хранит в себе идентификаторы объектов и лог текстовых сообщений с таймстемпами этих сообщений. Взаимодействие с приложением осуществляется исключительно с помощью брокера очередей.
По требованию внешней системы, микросервис может дописать сообщение в лог объекта с актуальным таймстемпом.
Количество сообщений в логе может быть большим, условно не ограничено. При этом должна быть обеспечена возможность получения сообщений лога по объекту в отсортированном по таймстемпу виде.
После проведения операции генерируется событие-ответ в одну из очередей.

Основные требования к воркерам приложения:
Код воркеров должен безопасно выполняться параллельно в разных процессах
Воркеры могут запускаться одновременно в любом числе экземпляров и выполняться произвольное время
Все операции должны обрабатываться корректно, без дублирования логов и потери сообщений при одновременной записи в лог одного объекта нескольких воркеров.

В пояснительной записке к выполненному заданию необходимо указать перечень используемых инструментов и технологий, способ развертки приложения, общий механизм работы (интерфейсы ввода/вывода)
  
Требования к окружению:
* Язык программирования: Go 1.17+
* Можно использовать: любые фреймворки, реляционные БД для хранения баланса, брокеры очередей, key-value хранилища, код должен быть готовым к покрытию unit тестами


## Способ развёртки
* Склонировать репозиторий
```bash
git clone git@github.com:savukhin/mind-software.git
```
* Чтобы развернуть среду с воркерами, запустите команду
```bash
docker compose up --build --remove-orphans
```
Если зайти по адресу http://localhost:2112/metrics, то можно увидеть стандартные метрики в go.

Увеличить количество баз данных можно добавлением блока с описанием базы данных по аналогии с postgresnode, причём необходимы одинаковые логины/пароли для всех узлов БД. Затем добавить новое название контейнера в поле окружения **POSTGRES_IPS** сервиса worker.

* Если вы хотите посмотреть поведение при нагрузке, то нужно запустить docker-compose.test.yaml:
```bash
docker-compose -f docker-compose.test.yaml up --build --remove-orphans
```
Это по сути то же окружение, что и в прошлом варианте, но с добавлением сервиса, который создаёт нагрузку (пишет в NATS)
Обратите внимание, что нагрузку можно изменить при помощи поля **QUERIES_MIN**, которое отражает количество запросов в минуту. Отправляются только запросы на добавление логов.
Если вы хотите увеличить количество реплик для тестирования, то надо изменить **services.worker.deploy.replicas** на нужное значение и не забыть закомментировать поле **services.worker.port**, если количество реплик больше, чем 1, так как нельзя несколько раз открыть один и тот же порт.
В этом случае воркер начнёт читать только после того, как подключиться к БД. По факту publisher может начать писать ему раньше, чем начёнтся чтение.

## Диаграмма взаимодействия

![Diargam](./readme/Diagram.png?raw=true "Diagram")
* [Nats](https://nats.io/) - брокер сообщений NATS, через которого приходят сообщения
* [Postgres](https://www.postgresql.org/) - База данных, в которой хранится информация
* [Hashring](https://pkg.go.dev/github.com/serialx/hashring) -  Подход к шардированию, при котором инстансы БД располагаются по кругу; вычисляется хэш ключа и отправляется в соответствующую БД.
* Workers - набор воркеров-решений поставленной задачи


## Топики брокера

В Nats три топика: 
* **logs** - логи, сообщение является json-строкой, которая десериализуется в объект следующего типа:
```go
type NatsLogMsg struct {
	ObjId uint64 `json:"id"`
	Log   string `json:"log"`
}
```

* **query** - запросы на сбор логов по идентицфикатору объекта, хранятся JSON-е, которая преобразуется в следующий объект:
```go
type NatsGetLogsMsg struct {
	ObjId uint64 `json:"id"`
}
```

* **response** - ответы на запросы из query:
```go
type NatsGetLogsMsg struct {
	ObjId uint64 `json:"id"`
}
```

## Механизм работы
0. Подключение к топикам NATS и к базам данных, создание хэшринга, автомиграции
1. Добавление новой записи
1.1. Сообщение читается из очереди logs
1.2. В hashring выбирается нужный шард БД по идентификатору объекта, который логируется, и записывается в этот шард лог
2. Вычитка логов
2.1. При запросе логов по идентификатору объекта снова выбирается нужный шард, который выдаёт данные
2.2. Возвращается список логов из шарда и записывается в топик response

## Обоснование выбора решений
1. Выбор БД
1.1. В качестве БД рассматривалась Cassandra - преимуществом является то, что в ней уже внутри реализован HashRing, плюс нам не нужно использовать в данной задаче любые ограничения (foreign key и так далее), а также все операции атомарные, что означает, что даже если посреди операции случится какая-то ошибка, то это не нарушит согласованности. Однако Cassandra - это нереляционная БД, причём не key-value, а в условии задачи не сказано, что такие разрешены, поэтому было решено не использовать её
1.2. В качестве БД также рассматривался Redis - внутри есть механизм шардирования, а также реплики и sentinel-узлы; плюс можно всё таки режим записи в файловое хранилище текущего состояния. Была идея делать RPUSH по идентификатору объекта, но к сожалению размер листа в Redis имеет своё ограничение на 2^32 - 1 элементов.
1.3. Выбран Postgres, потому что это реляционная БД, в ней есть соблюдение ACID и нет никаких ограничений на размер таблицы. Шардирование происходит популярным подходом HashRing.
2. Выбор брокера сообщений
2.1. RabbitMQ - популярное решение, но имеет свои недостатки при работе с большой нагрузкой
2.2. Kafka - полулярное решение, он связан с Zookeeper, но он разворачивается сложнее, чем NATS
2.3. NATS - универсальный вариант, этот сервис ориентирован на доставку без потери сообщений в принципе; он разворачивается легко и быстро, поддерживает работу в разных режимах: pub/sub, очередь (в данном случае сообщения читались из очереди) и так далее

## Переменные окружения
1. worker
1.1. POSTGRES_IPS - массив адресов узлов postgers, разделены через запятую
1.2. POSTGRES_PORT - порты узлов postgers
1.3. POSTGRES_USER - имя пользователя узлов postgers
1.4. POSTGRES_PASSWORD - пароль узлов postgers
1.5. POSTGRES_DB - название базы данных узлов postgers
1.6. POSTGRES_AUTOMIGRATE - нужно ли делать автомиграцию на узлах postgers (true или false)
1.7. NATS_URL - адрес NATS
1.8. NATS_LOGS_TOPIC - топик для получения логов в NATS
1.9. NATS_QUERY_TOPIC - топик для запросов в NATS
1.10. NATS_RESPONSE_TOPIC - топик для ответа NATS
1.11. MODE - режим работы (release или debug)
2. publisher
2.1. NATS_URL - адрес NATS
2.2. NATS_LOGS_TOPIC - топик для получения логов в NATS
2.3. QUERIES_MIN - количество запросов в минуту, которые генерирует паблишер
